<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>SlotLove</title>

<!-- Favicon -->
<link rel="icon" type="image/svg+xml" href="/static/favicon.svg" />
<link rel="icon" type="image/png" href="/static/favicon.svg" />

<!-- Google Font elegante -->
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">

<style>
  body {
    margin: 0;
    font-family: 'Poppins', sans-serif;
    background: linear-gradient(120deg, #f8d5ff 0%, #ffe5ec 50%, #e0e7ff 100%);
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    padding: 2rem 1rem 3rem;
  }

  .main-title {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    margin: 1rem 0 1.8rem;
    text-align: center;
    transition: all 0.3s;
  }

  .main-title img {
    filter: drop-shadow(0 8px 24px rgba(127,92,255,0.15));
    transition: all 0.3s ease;
  }

  .main-title img:hover {
    transform: scale(1.05);
    filter: drop-shadow(0 12px 32px rgba(127,92,255,0.25));
  }

  #cards {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    grid-template-rows: repeat(2, auto);
    gap: 2rem;
    justify-items: center;
    align-items: start;
    margin: 0.5rem auto 1.5rem;
    width: 100%;
    max-width: 800px;
    padding: 0 1rem;
  }

  .card {
    width: 200px;
    min-height: 200px;
    aspect-ratio: 1;
    padding: 1.25rem;
    border-radius: 18px;
    background: rgba(255,255,255,0.32);
    backdrop-filter: blur(10px) saturate(1.1);
    box-shadow: 0 4px 16px rgba(127,92,255,0.08), 0 2px 8px rgba(0,0,0,0.06);
    text-align: center;
    position: relative;
    transition: transform 0.25s, box-shadow 0.25s, background 0.3s, width 0.35s cubic-bezier(.4,1.4,.6,1), min-height 0.35s cubic-bezier(.4,1.4,.6,1);
    border: 1.2px solid rgba(127,92,255,0.10);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    overflow: hidden;
    perspective: 900px;
    cursor: pointer;
  }

  .card.expanded {
    width: 340px;
    min-height: 260px;
    z-index: 20;
    box-shadow: 0 12px 48px rgba(127,92,255,0.18), 0 4px 16px rgba(0,0,0,0.12);
  }

  .card .card-front, .card .card-back {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    width: 100%; height: 100%;
    backface-visibility: hidden;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    border-radius: 18px;
    transition: background 0.3s;
  }

  .card .card-back {
    background: rgba(40,30,60,0.97);
    color: #fff;
    transform: rotateY(180deg);
    padding: 1.2rem 1.1rem 1.1rem 1.1rem;
    font-size: 1.05rem;
    text-align: left;
    box-shadow: 0 8px 32px rgba(127,92,255,0.18);
    min-height: 180px;
    height: auto;
    max-height: 80vh;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    justify-content: flex-start;
  }

  .card.flipped .card-front {
    transform: rotateY(180deg);
  }

  .card.flipped .card-back {
    transform: rotateY(0deg);
  }

  .card .tips-tooltip {
    display: none;
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(40,30,60,0.72);
    color: #fff;
    font-size: 1.1rem;
    font-weight: 600;
    align-items: center;
    justify-content: center;
    z-index: 5;
    border-radius: 18px;
    pointer-events: auto;
    transition: opacity 0.25s;
    cursor: pointer;
  }

  .card:hover .tips-tooltip {
    display: flex;
    opacity: 1;
    animation: fadeIn 0.2s;
  }

  .card.zoomed .tips-tooltip {
    display: none !important;
  }

  .card.flipped .tips-tooltip {
    display: none !important;
  }

  .card:hover:not(.flipped) {
    background: rgba(40,30,60,0.13);
    box-shadow: 0 8px 32px rgba(40,30,60,0.13);
  }

  .card:hover {
    transform: translateY(-8px) scale(1.04);
    box-shadow: 0 16px 36px rgba(127,92,255,0.16), 0 4px 16px rgba(0,0,0,0.12);
  }

  .card.locked {
    outline: 2.5px solid #4caf50;
    box-shadow: 0 0 0 4px rgba(76,175,80,0.13), 0 8px 18px rgba(127,92,255,0.08);
  }

  .card h3 {
    font-size: 1.18rem;
    font-weight: 700;
    margin: 0 0 0.25rem 0;
    letter-spacing: 1.2px;
    color: #7f5cff;
    text-transform: uppercase;
    position: absolute;
    top: 0.7rem;
    left: 0.7rem;
    right: 0.7rem;
    text-align: center;
    z-index: 10;
  }

  .card p {
    font-size: 1.1rem;
    color: #333;
    font-weight: 500;
    line-height: 1.4;
    display: flex;
    align-items: center;
    justify-content: center;
    height: 40px;
    width: 100%;
    margin: 0;
    padding: 0;
  }

  .lock-btn {
    position: absolute;
    top: 0.75rem;
    right: 0.75rem;
    font-size: 1.1rem;
    cursor: pointer;
    user-select: none;
    width: 28px;
    height: 28px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    background: rgba(255,255,255,0.5);
    transition: all 0.2s;
    z-index: 15;
  }

  .lock-btn:hover {
    background: rgba(255,255,255,0.8);
    transform: scale(1.1);
  }

  .card-heart {
    position: absolute;
    bottom: 0.75rem;
    right: 0.75rem;
    font-size: 1.2rem;
    cursor: pointer;
    opacity: 0.6;
    transition: all 0.2s;
    background: none;
    border: none;
    padding: 0;
    width: 28px;
    height: 28px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    background: rgba(255,255,255,0.5);
    z-index: 15;
  }

  .card-heart:hover {
    transform: scale(1.1);
    opacity: 1;
    background: rgba(255,255,255,0.8);
  }

  .card-heart.liked {
    opacity: 1;
    color: #ff4081;
    background: rgba(255,255,255,0.8);
  }

  .info-btn {
    position: absolute;
    top: 0.75rem;
    left: 0.75rem;
    font-size: 1.1rem;
    cursor: pointer;
    opacity: 0.6;
    transition: all 0.2s;
    background: rgba(255,255,255,0.5);
    border: none;
    width: 28px;
    height: 28px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0;
    z-index: 15;
  }

  .info-btn:hover {
    transform: scale(1.1);
    opacity: 1;
    background: rgba(255,255,255,0.8);
  }

  .explanation-box {
    position: absolute;
    top: calc(100% + 0.5rem);
    left: -0.5rem;
    right: -0.5rem;
    background: linear-gradient(135deg, #fff3cd, #fff9e6);
    padding: 1rem;
    border-radius: 12px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    font-size: 0.92rem;
    color: #856404;
    z-index: 10;
    display: none;
    animation: fadeIn 0.3s ease-out;
    line-height: 1.5;
    text-align: left;
    border: 1px solid rgba(133,100,4,0.1);
  }

  button.spin {
    margin: 1rem 0 2rem;
    padding: 0.8rem 2.2rem;
    font-size: 1.1rem;
    font-weight: 600;
    border: none;
    border-radius: 999px;
    background: linear-gradient(90deg, #ff4081, #7f5cff, #00c6fb);
    color: #fff;
    letter-spacing: 0.7px;
    box-shadow: 0 6px 18px rgba(127,92,255,0.15);
    cursor: pointer;
    transition: transform 0.2s, box-shadow 0.2s, background 0.3s;
    outline: none;
  }

  button.spin:hover {
    transform: translateY(-2px) scale(1.02);
    box-shadow: 0 12px 28px rgba(127,92,255,0.2);
    background: linear-gradient(90deg, #7f5cff, #ff4081, #00c6fb);
  }

  button.spin:active {
    transform: translateY(0) scale(1);
    box-shadow: 0 6px 18px rgba(127,92,255,0.15);
  }

  button.spin:disabled {
    opacity: 0.7;
    cursor: not-allowed;
    transform: none;
  }

  #feedback {
    margin: 3rem 0 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 7rem;
    position: relative;
  }

  .feedback-row {
    display: flex;
    flex-direction: row;
    gap: 3.5rem;
    justify-content: center;
    margin: 0;
    position: relative;
  }

  .feedback-row::after {
    content: '';
    position: absolute;
    bottom: -3.5rem;
    left: 50%;
    transform: translateX(-50%);
    width: 80px;
    height: 2px;
    background: linear-gradient(90deg, transparent, rgba(127,92,255,0.2), transparent);
  }

  .fb-btn {
    font-size: 1.35rem;
    cursor: pointer;
    transition: all 0.2s;
    border: 1.5px solid #7f5cff;
    border-radius: 50%;
    background: #fff;
    padding: 0;
    box-shadow: 0 2px 6px rgba(127,92,255,0.1);
    outline: none;
    user-select: none;
    width: 52px;
    height: 52px;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .fb-btn:hover {
    transform: scale(1.13);
    box-shadow: 0 4px 12px rgba(127,92,255,0.15);
    background: #f8d5ff;
    border-color: #ff4081;
  }

  .fb-btn.osare {
    font-size: 0.95rem;
    font-weight: 600;
    color: #fff;
    background: linear-gradient(90deg, #ff4081, #7f5cff, #00c6fb);
    border: none;
    border-radius: 999px;
    padding: 1rem 2.5rem;
    margin-top: 1rem;
    box-shadow: 0 2px 8px rgba(127,92,255,0.15);
    letter-spacing: 0.5px;
    transition: all 0.2s;
    width: auto;
    height: auto;
  }

  .fb-btn.osare:hover {
    background: linear-gradient(90deg, #7f5cff, #ff4081, #00c6fb);
    transform: scale(1.05);
    box-shadow: 0 4px 12px rgba(127,92,255,0.2);
  }

  #ai-suggestion {
    margin: 2rem auto 0;
    padding: 1.2rem 1.8rem;
    background: linear-gradient(90deg, #fffbe7 60%, #e0e7ff 100%);
    border-radius: 14px;
    color: #856404;
    font-size: 1rem;
    box-shadow: 0 2px 8px rgba(127,92,255,0.08);
    font-weight: 500;
    text-align: center;
    border: 1px solid rgba(133,100,4,0.1);
    max-width: 600px;
    line-height: 1.5;
    display: none;
  }

  @media (max-width: 768px) {
    body {
      padding: 1rem 0.5rem 2rem;
    }
    
    #cards {
      grid-template-columns: repeat(2, 1fr);
      grid-template-rows: repeat(3, auto);
      gap: 1.5rem;
      padding: 0 0.5rem;
    }
    
    .card {
      width: 100%;
      max-width: 170px;
      min-height: 180px;
    }
    
    .main-title img {
      width: 100px;
      height: 100px;
    }
    
    .main-title div {
      font-size: 2rem;
    }
  }

  @media (max-width: 480px) {
    body {
      padding: 0.8rem 0.3rem 1.5rem;
    }
    
    #cards {
      grid-template-columns: 1fr;
      gap: 1rem;
      padding: 0 0.3rem;
    }
    
    .card {
      width: 100%;
      max-width: 280px;
      min-height: 160px;
    }

    #feedback {
      gap: 4rem;
      margin-top: 1.5rem;
    }

    .feedback-row::after {
      bottom: -2rem;
      width: 60px;
    }

    .fb-btn {
      width: 46px;
      height: 46px;
      font-size: 1.2rem;
    }

    .fb-btn.osare {
      padding: 0.8rem 1.6rem;
      font-size: 0.9rem;
    }
    
    .main-title img {
      width: 80px;
      height: 80px;
    }
    
    .main-title div {
      font-size: 1.8rem;
    }
  }

  @media (max-width: 360px) {
    body {
      padding: 0.5rem 0.2rem 1rem;
    }
    
    .card {
      max-width: 260px;
      min-height: 150px;
      padding: 1rem;
    }
    
    .main-title img {
      width: 70px;
      height: 70px;
    }
    
    .main-title div {
      font-size: 1.6rem;
    }
    
    #levelSel {
      font-size: 0.9rem;
      min-width: 100px;
      padding: 0.5rem 1.8rem 0.5rem 0.6rem;
    }
    
    .switch-label {
      font-size: 0.95rem;
    }
  }

  /* Stili per l'animazione slot machine */
  .slot-container {
    min-height: 120px;
    height: 120px;
    width: 100%;
    overflow: hidden;
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 0;
    padding: 0;
  }

  .slot-reel {
    position: absolute;
    width: 100%;
    left: 0;
    top: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    will-change: transform;
    transition: none;
  }

  .slot-item {
    font-size: 1.18rem;
    font-weight: 700;
    color: #222;
    background: none;
    padding: 0.2rem 0.5rem;
    text-align: center;
    transition: color 0.2s;
    white-space: pre-line;
    line-height: 1.25;
    min-height: 120px;
    height: 120px;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .card p.spinning {
    transition: transform 0.1s linear;
  }

  #levelSel {
    display: block;
    margin: 0 auto 1.2rem auto;
    padding: 0.7rem 2.2rem 0.7rem 1.1rem;
    font-size: 1.08rem;
    font-family: 'Poppins', sans-serif;
    font-weight: 600;
    color: #7f5cff;
    background: linear-gradient(90deg, #ffe5ec 60%, #e0e7ff 100%);
    border: 2px solid #e0e7ff;
    border-radius: 999px;
    box-shadow: 0 2px 8px rgba(127,92,255,0.08);
    outline: none;
    transition: border 0.2s, box-shadow 0.2s;
    appearance: none;
    position: relative;
    cursor: pointer;
    max-width: 220px;
    min-width: 180px;
  }
  #levelSel:focus, #levelSel:hover {
    border: 2px solid #ff4081;
    box-shadow: 0 4px 16px rgba(127,92,255,0.13);
    background: linear-gradient(90deg, #f8d5ff 60%, #e0e7ff 100%);
    color: #ff4081;
  }
  #levelSel option {
    color: #7f5cff;
    font-weight: 500;
    background: #fff;
  }
  /* Custom dropdown arrow */
  #levelSel {
    background-image: url('data:image/svg+xml;utf8,<svg fill="%237f5cff" height="20" viewBox="0 0 20 20" width="20" xmlns="http://www.w3.org/2000/svg"><path d="M7.293 8.293a1 1 0 011.414 0L10 9.586l1.293-1.293a1 1 0 111.414 1.414l-2 2a1 1 0 01-1.414 0l-2-2a1 1 0 010-1.414z"/></svg>');
    background-repeat: no-repeat;
    background-position: right 1.1rem center;
    background-size: 1.2em;
  }
  @media (max-width: 480px) {
    #levelSel {
      font-size: 0.98rem;
      min-width: 120px;
      padding: 0.6rem 2rem 0.6rem 0.8rem;
    }
  }

  .switch-label {
    display: flex;
    align-items: center;
    gap: 0.7rem;
    margin: 0 auto 1.2rem auto;
    font-family: 'Poppins', sans-serif;
    font-weight: 600;
    color: #7f5cff;
    font-size: 1.08rem;
    cursor: pointer;
    user-select: none;
    justify-content: center;
  }
  .switch {
    position: relative;
    display: inline-block;
    width: 48px;
    height: 28px;
    margin-right: 0.3rem;
  }
  .switch input {
    opacity: 0;
    width: 0;
    height: 0;
  }
  .slider {
    position: absolute;
    cursor: pointer;
    top: 0; left: 0; right: 0; bottom: 0;
    background: linear-gradient(90deg, #ffe5ec 60%, #e0e7ff 100%);
    border-radius: 999px;
    transition: background 0.3s;
    box-shadow: 0 2px 8px rgba(127,92,255,0.08);
  }
  .slider:before {
    position: absolute;
    content: "";
    height: 22px;
    width: 22px;
    left: 3px;
    bottom: 3px;
    background: linear-gradient(90deg, #ff4081, #7f5cff, #00c6fb);
    border-radius: 50%;
    transition: transform 0.3s, background 0.3s;
    box-shadow: 0 2px 8px rgba(127,92,255,0.13);
  }
  .switch input:checked + .slider {
    background: linear-gradient(90deg, #f8d5ff 60%, #e0e7ff 100%);
  }
  .switch input:checked + .slider:before {
    transform: translateX(20px);
    background: linear-gradient(90deg, #7f5cff, #ff4081, #00c6fb);
  }
  .switch-label .switch {
    margin-bottom: 0;
  }
  @media (max-width: 480px) {
    .switch-label {
      font-size: 0.98rem;
    }
    .switch {
      width: 38px;
      height: 22px;
    }
    .slider:before {
      height: 16px;
      width: 16px;
      left: 3px;
      bottom: 3px;
    }
  }

  /* Aggiungi stile CSS per effetto illuminato su cuoricino e cacchina */
  .card-heart.active {
    color: #ff1a1a;
    filter: drop-shadow(0 0 12px #ff1a1a) saturate(2);
    transform: scale(1.35);
    transition: all 0.15s;
    z-index: 2;
  }
  .card-heart:hover {
    color: #e74c3c;
    filter: drop-shadow(0 0 6px #e74c3c);
    transform: scale(1.2);
    transition: all 0.15s;
  }
  .card-dislike.active {
    color: #a0522d;
    filter: drop-shadow(0 0 12px #a0522d) saturate(2);
    transform: scale(1.35);
    transition: all 0.15s;
    z-index: 2;
  }
  .card-dislike:hover {
    color: #8d5524;
    filter: drop-shadow(0 0 6px #8d5524);
    transform: scale(1.2);
    transition: all 0.15s;
  }

  /* Overlay per card espansa */
  .overlay-card-zoom {
    position: fixed;
    top: 0; left: 0; width: 100vw; height: 100vh;
    background: rgba(40,30,60,0.22);
    z-index: 1000;
    display: flex;
    align-items: center;
    justify-content: center;
    animation: fadeIn 0.18s;
  }
  .card.zoomed {
    position: fixed !important;
    z-index: 1010 !important;
    left: 50% !important;
    top: 50% !important;
    transform: translate(-50%, -50%) scale(1.25) !important;
    box-shadow: 0 16px 64px 0 rgba(40,30,60,0.32), 0 2px 8px rgba(127,92,255,0.18) !important;
    transition: transform 0.28s cubic-bezier(.4,1.4,.6,1), box-shadow 0.28s, left 0s, top 0s;
    background: rgba(255,255,255,0.98) !important;
    pointer-events: auto;
    padding: 2rem !important;
    word-wrap: break-word !important;
    overflow-wrap: break-word !important;
    max-width: 90vw !important;
    max-height: 90vh !important;
    overflow-y: auto !important;
  }
  
  @media (max-width: 768px) {
    .card.zoomed {
      transform: translate(-50%, -50%) scale(1.1) !important;
      padding: 1.5rem !important;
      max-width: 95vw !important;
      max-height: 85vh !important;
    }
  }
  
  @media (max-width: 480px) {
    .card.zoomed {
      transform: translate(-50%, -50%) scale(1) !important;
      padding: 1rem !important;
      max-width: 98vw !important;
      max-height: 80vh !important;
    }
  }
  body.no-scroll {
    overflow: hidden !important;
  }

  .card-dislike {
    position: absolute;
    bottom: 0.75rem;
    left: 0.75rem;
    font-size: 1.2rem;
    cursor: pointer;
    opacity: 0.6;
    transition: all 0.2s;
    background: none;
    border: none;
    padding: 0;
    width: 28px;
    height: 28px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    background: rgba(255,255,255,0.5);
    z-index: 15;
  }

  .zoomed-tips-container {
    position: fixed;
    z-index: 1010;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    background: rgba(40,30,60,0.97);
    color: #fff;
    padding: 2rem;
    border-radius: 18px;
    box-shadow: 0 16px 64px 0 rgba(40,30,60,0.32), 0 2px 8px rgba(127,92,255,0.18);
    max-width: 90vw;
    max-height: 90vh;
    overflow-y: auto;
    word-wrap: break-word;
    overflow-wrap: break-word;
    font-size: 1.2rem;
    line-height: 1.6;
    text-align: left;
    transition: transform 0.28s cubic-bezier(.4,1.4,.6,1);
  }
  
  @media (max-width: 768px) {
    .zoomed-tips-container {
      padding: 1.5rem;
      max-width: 95vw;
      max-height: 85vh;
      font-size: 1.1rem;
    }
  }
  
  @media (max-width: 480px) {
    .zoomed-tips-container {
      padding: 1rem;
      max-width: 98vw;
      max-height: 80vh;
      font-size: 1rem;
      border-radius: 12px;
    }
  }

  #mode-switch-bar {
    position: sticky;
    top: 0;
    z-index: 100;
    background: linear-gradient(120deg, #f8d5ff 0%, #ffe5ec 50%, #e0e7ff 100%);
    padding: 0.5rem 0 0.5rem 0;
    width: 100vw;
    display: flex;
    justify-content: center;
    align-items: center;
    margin-bottom: 1.2rem;
  }
  .mode-switch-label {
    display: flex;
    align-items: center;
    gap: 0.7rem;
    font-family: 'Poppins', sans-serif;
    font-weight: 600;
    color: #7f5cff;
    font-size: 1.08rem;
    cursor: pointer;
    user-select: none;
    justify-content: center;
  }
  .mode-label {
    min-width: 110px;
    text-align: center;
    opacity: 0.6;
    transition: color 0.2s, opacity 0.2s;
    color: #7f5cff;
    font-weight: 500;
  }
  .mode-label.active {
    color: #ff4081;
    opacity: 1;
    font-weight: 700;
  }
  .mode-switch {
    position: relative;
    display: inline-block;
    width: 48px;
    height: 28px;
    margin: 0 0.3rem;
  }
  .mode-switch input {
    opacity: 0;
    width: 0;
    height: 0;
  }
  .mode-slider {
    position: absolute;
    cursor: pointer;
    top: 0; left: 0; right: 0; bottom: 0;
    background: linear-gradient(90deg, #ffe5ec 60%, #e0e7ff 100%);
    border-radius: 999px;
    transition: background 0.3s;
    box-shadow: 0 2px 8px rgba(127,92,255,0.08);
  }
  .mode-slider:before {
    position: absolute;
    content: "";
    height: 22px;
    width: 22px;
    left: 3px;
    bottom: 3px;
    background: linear-gradient(90deg, #ff4081, #7f5cff, #00c6fb);
    border-radius: 50%;
    transition: transform 0.3s, background 0.3s;
    box-shadow: 0 2px 8px rgba(127,92,255,0.13);
  }
  .mode-switch input:checked + .mode-slider {
    background: linear-gradient(90deg, #f8d5ff 60%, #e0e7ff 100%);
  }
  .mode-switch input:checked + .mode-slider:before {
    transform: translateX(20px);
    background: linear-gradient(90deg, #7f5cff, #ff4081, #00c6fb);
  }
  .mode-switch-label .mode-switch {
    margin-bottom: 0;
  }
  @media (max-width: 480px) {
    .mode-switch-label {
      font-size: 0.98rem;
    }
    .mode-label {
      min-width: 80px;
      font-size: 0.98rem;
    }
    .mode-switch {
      width: 38px;
      height: 22px;
    }
    .mode-slider:before {
      height: 16px;
      width: 16px;
      left: 3px;
      bottom: 3px;
    }
  }
  /* Centra le card quando sono solo 2 */
  #cards.centered-2 {
    display: flex !important;
    justify-content: center;
    align-items: flex-start;
    gap: 2rem;
    flex-wrap: wrap;
    margin: 0.5rem auto 1.5rem;
    width: 100%;
    max-width: 800px;
    padding: 0 1rem;
  }
  @media (max-width: 768px) {
    #cards.centered-2 {
      gap: 1.5rem;
    }
  }
  @media (max-width: 480px) {
    #cards.centered-2 {
      flex-direction: column;
      align-items: center;
      gap: 1rem;
      padding: 0 0.3rem;
    }
  }
</style>
</head>
<body>
  <div class="main-title">
    <img src="logo.svg" alt="SlotLove" style="width: 120px; height: 120px; margin-bottom: 1rem;">
    <div style="font-size: 2.5rem; font-weight: 700; background: linear-gradient(90deg, #ff4081, #7f5cff, #00c6fb); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; text-fill-color: transparent; letter-spacing: 1.5px; text-shadow: 0 4px 24px rgba(127,92,255,0.12); text-align: center; transition: all 0.3s; text-transform: uppercase;">SlotLove</div>
  </div>
  <div id="mode-switch-bar">
    <label class="mode-switch-label">
      <span id="mode-label-base" class="mode-label active">Modalit√† base</span>
      <span class="mode-switch">
        <input type="checkbox" id="expertSwitch">
        <span class="mode-slider"></span>
      </span>
      <span id="mode-label-expert" class="mode-label">Modalit√† esperto</span>
    </label>
  </div>
  <select id="levelSel" style="margin-bottom:1.2rem;max-width:220px;">
    <option value="">Qualsiasi</option>
    <option value="L1">L1 ‚Äì Soft Vanilla</option>
    <option value="L2">L2 ‚Äì Public Tease</option>
    <option value="L3">L3 ‚Äì Rough Romance</option>
    <option value="L4">L4 ‚Äì Daring Play</option>
    <option value="L5">L5 ‚Äì Bold Taboo</option>
    <option value="L6">L6 ‚Äì Wild Extreme</option>
  </select>
  <label class="switch-label">
    <span style="font-size:1.18em;">üë´</span>
    <span>Con altri</span>
    <span class="switch">
      <input type="checkbox" id="partChk">
      <span class="slider"></span>
    </span>
  </label>
  <button class="spin" id="spinBtn">Spin</button>
  <div id="cards"></div>
  <div id="feedback" style="display:none;">
    <div class="feedback-row">
      <span class="fb-btn" id="like" title="Mi piace">‚ù§Ô∏è</span>
      <span class="fb-btn" id="dislike" title="Non mi piace">üí©</span>
    </div>
    <button class="fb-btn osare" id="osareBtn" title="Questa scelta √® osare!">QUESTO √à OSARE</button>
  </div>

<script>
const cardsDiv=document.getElementById('cards');
const feedbackDiv=document.getElementById('feedback');
let currentCodes={},locked={};
let allOptions = null;
let lastSpinData = null;
let mapping = null;
let mappingReady = false;

// Mapping corretto tra i nomi delle categorie in inglese e italiano
const categories = [
  'azione',
  'outfit',
  'luogo',
  'energia',
  'oggetto',
  'extra'
];

// Modalit√† expert flag
let expertMode = false;

// Aggiorna lo switch modalit√†
const expertSwitch = document.getElementById('expertSwitch');
const modeLabelBase = document.getElementById('mode-label-base');
const modeLabelExpert = document.getElementById('mode-label-expert');
expertSwitch.checked = false;
expertSwitch.onchange = () => {
  expertMode = expertSwitch.checked;
  if (expertMode) {
    modeLabelBase.classList.remove('active');
    modeLabelExpert.classList.add('active');
  } else {
    modeLabelBase.classList.add('active');
    modeLabelExpert.classList.remove('active');
  }
  if (lastSpinData) {
    renderCards(lastSpinData);
  } else {
    renderEmptyCards();
  }
};

// Carica mapping.json all'avvio
async function loadMapping() {
  try {
    const response = await fetch('/static/data/mapping.json');
    mapping = await response.json();
    mappingReady = true;
    document.getElementById('spinBtn').disabled = false;
    document.getElementById('spinBtn').style.opacity = '1';
  } catch (e) {
    mapping = {};
    mappingReady = false;
    document.getElementById('spinBtn').disabled = true;
    document.getElementById('spinBtn').style.opacity = '0.7';
  }
}

// Funzione per caricare tutte le opzioni all'avvio
async function loadAllOptions() {
  try {
    const response = await fetch('/spin');
    const data = await response.json();
    console.log('Loaded options:', data.options); // Debug
    allOptions = data.options || {};
    // Non chiamare pi√π renderEmptyCards qui
    document.getElementById('spinBtn').disabled = false;
    document.getElementById('spinBtn').style.opacity = '1';
  } catch (error) {
    console.error('Error loading options:', error);
    // Mostra comunque le card vuote
    renderEmptyCards();
    document.getElementById('spinBtn').disabled = true;
    document.getElementById('spinBtn').style.opacity = '0.7';
  }
}

function renderEmptyCards() {
  cardsDiv.innerHTML = '';
  // Mostra solo 2 card se non expert
  const catsToShow = expertMode ? categories : ['azione', 'luogo'];
  if (!expertMode && catsToShow.length === 2) {
    cardsDiv.classList.add('centered-2');
  } else {
    cardsDiv.classList.remove('centered-2');
  }
  catsToShow.forEach(cat => {
    const card = document.createElement('div');
    card.className = 'card';
    card.setAttribute('data-backend', cat);
    card.innerHTML = `<div class="card-front">
      <div class="lock-btn">üîì<\/div>
      <button class="info-btn" style="display: none;">‚ùì<\/button>
      <h3>${cat}<\/h3>
      <div class="slot-container"><div class="slot-reel"><div class="slot-item">...<\/div><\/div><\/div>
      <button class="card-heart" style="display: none;">‚ù§Ô∏è<\/button>
      <div class="explanation-box"></div>
      <div class="tips-tooltip">Consigli<\/div>
    <\/div>
    <div class="card-back">
      <div style="font-size:1.15em;font-weight:600;margin-bottom:0.7em;">Consigli<\/div>
      <div style="white-space:pre-line;">Nessun consiglio disponibile.<\/div>
    <\/div>`;
    card.querySelector('.lock-btn').style.visibility = 'hidden';
    card.querySelector('.info-btn').style.visibility = 'hidden';
    cardsDiv.appendChild(card);
  });
  feedbackDiv.style.display = 'none';
}

// Funzione universale per ottenere la label dal mapping
function getLabel(code) {
  if (!mapping) return code;
  const val = mapping[code];
  if (val === undefined) {
    console.warn('Codice non trovato in mapping:', code);
    return code;
  }
  if (typeof val === 'object' && val.label) return val.label;
  if (typeof val === 'string') return val;
  return code;
}

// AGGIUNGI overlay modale per explanation box
const modalHtml = `
  <div id="explanation-modal" style="display:none;position:fixed;z-index:1000;top:0;left:0;width:100vw;height:100vh;background:rgba(0,0,0,0.25);align-items:center;justify-content:center;">
    <div id="explanation-content" style="background:linear-gradient(135deg,#fff3cd,#fff9e6);padding:2rem 1.5rem 1.5rem 1.5rem;border-radius:18px;box-shadow:0 8px 32px rgba(127,92,255,0.18);max-width:350px;width:90vw;position:relative;">
      <button id="close-explanation" style="position:absolute;top:0.7rem;right:0.7rem;font-size:1.3em;background:none;border:none;cursor:pointer;opacity:0.7;">‚úñ</button>
      <div id="explanation-text" style="font-size:1.05em;color:#856404;line-height:1.5;text-align:left;"></div>
    </div>
  </div>`;
if (!document.getElementById('explanation-modal')) {
  document.body.insertAdjacentHTML('beforeend', modalHtml);
}
const modal = document.getElementById('explanation-modal');
const modalText = document.getElementById('explanation-text');
const modalClose = document.getElementById('close-explanation');
modalClose.onclick = () => { modal.style.display = 'none'; };
modal.onclick = (e) => { if (e.target === modal) modal.style.display = 'none'; };

function showExplanation(text) {
  modalText.innerHTML = text;
  modal.style.display = 'flex';
}

// Aggiungi funzione per attivare i listener sui bottoni di lock
function activateLockListeners() {
  document.querySelectorAll('.card').forEach(card => {
    const lockBtn = card.querySelector('.lock-btn');
    if (!lockBtn) return;
    lockBtn.style.visibility = 'visible';
    lockBtn.onclick = (e) => {
      e.stopPropagation();
      const cat = card.getAttribute('data-backend');
      const code = (lastSpinData && lastSpinData.codes && lastSpinData.codes[cat]) || null;
      if (code) {
        toggleLock(cat, code);
      }
    };
  });
}

function activateExplanationListeners() {
  document.querySelectorAll('.card').forEach(card => {
    const infoBtn = card.querySelector('.info-btn');
    if (!infoBtn) return;
    infoBtn.style.display = 'block';
    infoBtn.onclick = (e) => {
      e.stopPropagation();
      // Prendi il codice della card
      const cat = card.getAttribute('data-backend');
      const code = (lastSpinData && lastSpinData.codes && lastSpinData.codes[cat]) || null;
      let explanation = '';
      if (mapping && mapping[code] && typeof mapping[code] === 'object' && mapping[code].explanation) {
        explanation = mapping[code].explanation;
      } else {
        explanation = 'Ops, ci hai beccati: qui manca la spiegazione!';
      }
      showExplanation(explanation);
    };
  });
}

function renderCards(data){
  lastSpinData = data;
  cardsDiv.innerHTML='';
  // Mostra solo 2 card se non expert
  const catsToShow = expertMode ? categories : ['azione', 'luogo'];
  if (!expertMode && catsToShow.length === 2) {
    cardsDiv.classList.add('centered-2');
  } else {
    cardsDiv.classList.remove('centered-2');
  }
  Object.entries(data.codes).forEach(([cat,code])=>{
    if (!catsToShow.includes(cat)) return;
    let label = getLabel(code);
    let explanation = '';
    let tips = '';
    if (mapping && mapping[code] && typeof mapping[code] === 'object') {
      explanation = mapping[code].explanation || '';
      tips = mapping[code].tips || '';
    }
    let feedbackBtns = `
      <button class=\"card-dislike\" style=\"position:absolute;bottom:8px;left:8px;font-size:1.4em;background:none;border:none;cursor:pointer;\">üí©</button>
      <button class=\"card-heart\" style=\"position:absolute;bottom:8px;right:8px;font-size:1.4em;background:none;border:none;cursor:pointer;\">‚ù§Ô∏è</button>
    `;
    const card=document.createElement('div');
    card.className='card'+(locked[cat]?' locked':'');
    card.setAttribute('data-backend', cat);
    card.style.position = 'relative';
    card.innerHTML = `
      <div class=\"card-front\">
        <div class=\"lock-btn\">${locked[cat]?'üîí':'üîì'}<\/div>
        <button class=\"info-btn\">‚ùì<\/button>
        <h3>${cat}<\/h3>
        <div class=\"slot-container\"><div class=\"slot-reel\"><div class=\"slot-item\">${label}<\/div><\/div><\/div>
        ${feedbackBtns}
        <div class=\"explanation-box\">${explanation}<\/div>
        <div class=\"tips-tooltip\">Consigli<\/div>
      <\/div>
      <div class=\"card-back\">
        <div style=\"font-size:1.15em;font-weight:600;margin-bottom:0.7em;\">Consigli</div>
        <div style=\"white-space:pre-line;\">${tips ? tips : 'Nessun consiglio disponibile.'}<\/div>
      <\/div>
    `;
    cardsDiv.appendChild(card);
    const fb = getFeedback(code);
    if (fb.like > 0) card.querySelector('.card-heart').classList.add('active');
    if (fb.dislike > 0) card.querySelector('.card-dislike').classList.add('active');
    if (fb.osare > 0) card.querySelector('.card-dare').classList.add('active');
    let contextKey = null;
    if (cat === 'luogo' && data.codes['azione']) contextKey = data.codes['azione'];
    attachFeedbackButtons(card, code, contextKey);
    // Gestione zoom/flip/consigli - LOGICA SEMPLIFICATA E FUNZIONANTE
    card.onclick = function(e) {
      console.log('Card clicked!', e.target); // Debug
      
      // Se click su lock, info, feedback: non fare nulla
      if (e.target.closest('.lock-btn') || e.target.closest('.info-btn') || e.target.closest('.card-heart') || e.target.closest('.card-dislike')) {
        console.log('Click su bottoni, ignoro'); // Debug
        return;
      }
      
      // Se la card √® gi√† zoomata
      if (card.classList.contains('zoomed')) {
        // Se click su tips-tooltip (Consigli): solo flip
        if (e.target.closest('.tips-tooltip')) {
          console.log('Click su Consigli in overlay, faccio flip'); // Debug
          e.stopPropagation();
          card.classList.toggle('flipped');
          return;
        }
        // Altrimenti chiudi
        console.log('Card gi√† zoomata, chiudo'); // Debug
        closeZoomedCard();
        return;
      }
      
      // Altrimenti, apri overlay/zoom (primo click)
      console.log('Apro overlay/zoom'); // Debug
      openZoomedCard(card);
    };
  });
  activateExplanationListeners();
  activateLockListeners();
  feedbackDiv.style.display='block';
}

function toggleLock(cat,code){
  if(locked[cat]) delete locked[cat]; else locked[cat]=code;
  document.querySelectorAll('.card').forEach(c=>{
    if(c.getAttribute('data-backend')===cat){
      c.classList.toggle('locked');
      c.querySelector('.lock-btn').innerText=locked[cat]?'üîí':'üîì';
    }
  });
}

function easeOutBack(t) {
  const c1 = 1.70158;
  const c3 = c1 + 1;
  return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
}

// Altezza fissa generosa per tutte le slot (gestisce label su 3 righe)
const SLOT_ITEM_HEIGHT = 120;

async function startSpinningAnimation(finalChoices) {
  if (!allOptions) return;
  const cards = document.querySelectorAll('.card');
  const spinDuration = 3000; // Durata maggiore per animazione pi√π fluida
  const cycles = 18; // numero di "giri" minimi prima di fermarsi
  const itemHeight = SLOT_ITEM_HEIGHT; // Usa la costante corretta
  const animationPromises = [];
  cards.forEach((card, index) => {
    const backendCategory = card.getAttribute('data-backend');
    if (locked[backendCategory]) {
      animationPromises.push(Promise.resolve());
      return;
    }
    const slotContainer = card.querySelector('.slot-container');
    const slotReel = card.querySelector('.slot-reel');
    if (!slotContainer || !slotReel) return;
    const options = allOptions[backendCategory] || [];
    const finalChoice = finalChoices.codes[backendCategory];
    // Costruisci la sequenza: tutte le opzioni ripetute + la finale
    let sequence = [];
    let slotCycles = 40; // pi√π cicli per effetto slot pi√π lungo
    for (let i = 0; i < slotCycles; i++) sequence.push(options[i % options.length]);
    // Buffer zone: 5 copie della scelta finale per rallentamento naturale
    for (let i = 0; i < 5; i++) {
      sequence.push(finalChoice);
    }
    // Popola la slot-reel con gli elementi
    slotReel.innerHTML = '';
    sequence.forEach(code => {
      const div = document.createElement('div');
      div.className = 'slot-item';
      div.textContent = getLabel(code);
      div.style.minHeight = SLOT_ITEM_HEIGHT + 'px';
      div.style.height = SLOT_ITEM_HEIGHT + 'px';
      slotReel.appendChild(div);
    });
    // Animazione fluida con transizione CSS controllata
    let start = null;
    // La posizione finale deve fermarsi sulla PRIMA delle 5 copie della scelta finale
    let totalDistance = itemHeight * (sequence.length - 5);
    
    // Imposta la posizione iniziale
    slotReel.style.transform = 'translateY(0px)';
    slotReel.style.transition = 'none';
    
    // Forza un reflow per assicurarsi che la posizione iniziale sia applicata
    slotReel.offsetHeight;
    
    animationPromises.push(new Promise(resolve => {
      // Imposta la transizione per l'animazione
      slotReel.style.transition = `transform ${spinDuration}ms cubic-bezier(0.25, 0.46, 0.45, 0.94)`;
      
      // Avvia l'animazione
      requestAnimationFrame(() => {
        slotReel.style.transform = `translateY(-${totalDistance}px)`;
      });
      
      // Aspetta che l'animazione finisca
      setTimeout(() => {
        // Assicurati che la posizione finale sia esatta
        slotReel.style.transition = 'none';
        slotReel.style.transform = `translateY(-${totalDistance}px)`;
        
        // Aggiorna explanation box
        let explanation = '';
        if (mapping && mapping[finalChoice] && typeof mapping[finalChoice] === 'object' && mapping[finalChoice].explanation) {
          explanation = mapping[finalChoice].explanation;
        } else {
          explanation = 'Ops, ci hai beccati: qui manca la spiegazione!';
        }
        let explanationBox = card.querySelector('.explanation-box');
        if (explanationBox) explanationBox.innerHTML = explanation;
        activateExplanationListeners();
        activateLockListeners();
        resolve();
      }, spinDuration + 50); // Piccolo margine per sicurezza
    }));
  });
  await Promise.all(animationPromises);
}

// Gestione feedback locale
function getFeedbackStore() {
  return JSON.parse(localStorage.getItem('feedbackStore') || '{}');
}
function setFeedbackStore(store) {
  localStorage.setItem('feedbackStore', JSON.stringify(store));
}
function saveFeedback(code, type) {
  const store = getFeedbackStore();
  if (!store[code]) store[code] = {like:0, dislike:0, osare:0};
  store[code][type] = (store[code][type]||0) + 1;
  setFeedbackStore(store);
  
  // Invia anche al backend
  sendFeedbackToBackend(code, type);
}

// Funzione per inviare feedback al backend
async function sendFeedbackToBackend(code, type) {
  try {
    // Trova la categoria del codice
    let category = '';
    for (const [cat, codes] of Object.entries(allOptions)) {
      if (codes.includes(code)) {
        category = cat;
        break;
      }
    }
    
    // Crea la combinazione completa per il contesto
    let combination = '';
    if (currentCodes) {
      for (const [cat, catCode] of Object.entries(currentCodes)) {
        if (catCode && cat !== 'partecipanti') {
          const label = mapping && mapping[catCode] ? 
            (typeof mapping[catCode] === 'object' ? mapping[catCode].label : mapping[catCode]) : 
            catCode;
          combination += `${cat}: ${label}\n`;
        }
      }
    }
    
    // Invia al backend
    const response = await fetch('/card-feedback', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        category: category,
        code: code,
        like: type === 'like',
        combination: combination
      })
    });
    
    if (!response.ok) {
      console.error('Errore nell\'invio feedback al backend');
    }
  } catch (error) {
    console.error('Errore nell\'invio feedback:', error);
  }
}

function getFeedback(code) {
  const store = getFeedbackStore();
  return store[code] || {like:0, dislike:0, osare:0};
}

// Weighted choice che tiene conto dei feedback
function weightedChoice(options, contextKey=null) {
  if (!options.length) return null;
  // 10% di probabilit√† di "osare" (scegliere tra le meno gradite)
  const dareToDare = Math.random() < 0.10;
  // Calcola i pesi
  let weights = options.map(opt => {
    let fb = getFeedback(opt);
    // Se combinazione, somma feedback della combinazione e della singola scelta
    if (contextKey) {
      const comboFb = getFeedback(contextKey + '|' + opt);
      fb = {
        like: (fb.like||0) + (comboFb.like||0),
        dislike: (fb.dislike||0) + (comboFb.dislike||0),
        osare: (fb.osare||0) + (comboFb.osare||0)
      };
    }
    // Peso base
    let w = 1 + fb.like*2 + fb.osare;
    w -= fb.dislike*2;
    if (w < 0.1) w = 0.1; // mai zero
    return w;
  });
  // Se "osare", scegli tra le meno gradite (peso minore)
  if (dareToDare) {
    let minW = Math.min(...weights);
    let daringOpts = options.filter((_,i)=>weights[i]===minW);
    return daringOpts[Math.floor(Math.random()*daringOpts.length)];
  }
  // Altrimenti estrai pesato
  let sum = weights.reduce((a,b)=>a+b,0);
  let r = Math.random()*sum;
  for(let i=0;i<options.length;i++){
    if(r<weights[i]) return options[i];
    r-=weights[i];
  }
  return options[0];
}

// Modifica i bottoni like/dislike/osare per salvare feedback
function attachFeedbackButtons(card, code, contextKey) {
  const likeBtn = card.querySelector('.card-heart');
  const dislikeBtn = card.querySelector('.card-dislike');
  // Like
  if (likeBtn) likeBtn.onclick = ()=>{
    const isActive = likeBtn.classList.contains('active');
    if (isActive) {
      likeBtn.classList.remove('active');
      removeFeedback(code, 'like');
      if(contextKey) removeFeedback(contextKey+'|'+code, 'like');
    } else {
      likeBtn.classList.add('active');
      if (dislikeBtn) dislikeBtn.classList.remove('active');
      saveFeedback(code, 'like');
      if(contextKey) saveFeedback(contextKey+'|'+code, 'like');
      removeFeedback(code, 'dislike');
      if(contextKey) removeFeedback(contextKey+'|'+code, 'dislike');
    }
  };
  // Dislike
  if (dislikeBtn) dislikeBtn.onclick = ()=>{
    const isActive = dislikeBtn.classList.contains('active');
    if (isActive) {
      dislikeBtn.classList.remove('active');
      removeFeedback(code, 'dislike');
      if(contextKey) removeFeedback(contextKey+'|'+code, 'dislike');
    } else {
      dislikeBtn.classList.add('active');
      if (likeBtn) likeBtn.classList.remove('active');
      saveFeedback(code, 'dislike');
      if(contextKey) saveFeedback(contextKey+'|'+code, 'dislike');
      removeFeedback(code, 'like');
      if(contextKey) removeFeedback(contextKey+'|'+code, 'like');
    }
  };
}

// Funzione per rimuovere feedback
function removeFeedback(code, type) {
  const store = getFeedbackStore();
  if (store[code] && store[code][type] > 0) {
    store[code][type]--;
    setFeedbackStore(store);
  }
}

function isCompatible(actionCode, luogoCode) {
  function getList(code, key) {
    const val = mapping && mapping[code];
    if (val && typeof val === 'object') return val[key] || [];
    return [];
  }
  const needs = getList(actionCode, 'needs');
  const supports = getList(luogoCode, 'supports');
  return needs.every(n => supports.includes(n));
}

// Modifica la funzione spin per applicare il filtro del livello a tutte le categorie
async function spin() {
  if (!mappingReady) {
    alert('Attendi il caricamento delle etichette...');
    return;
  }
  const spinBtn = document.getElementById('spinBtn');
  spinBtn.disabled = true;
  spinBtn.style.opacity = '0.7';
  feedbackDiv.style.display = 'none';
  cardsDiv.style.animation = 'slotShake .4s ease-in-out';
  setTimeout(() => cardsDiv.style.animation = '', 400);
  try {
    const level = document.getElementById('levelSel').value;
    const spinPart = document.getElementById('partChk').checked;
    
    // Funzione per filtrare opzioni per livello
    function filterByLevel(options, category) {
      if (!level) return options; // Se nessun livello selezionato, mostra tutto
      return options.filter(code => {
        const mappingEntry = mapping[code];
        if (!mappingEntry || typeof mappingEntry !== 'object') return true; // Se non c'√® mapping, include
        const codeLevel = mappingEntry.level;
        return codeLevel === level; // Solo codici del livello selezionato
      });
    }
    // Funzione per filtrare azioni di gruppo se richiesto
    function filterByGroup(options, category) {
      if (category !== 'azione') return options;
      
      return options.filter(code => {
        const mappingEntry = mapping[code];
        if (!mappingEntry || typeof mappingEntry !== 'object') return true; // Se non c'√® mapping, include
        const needs = mappingEntry.needs || [];
        const hasGroupTags = Array.isArray(needs) && (needs.includes('group') || needs.includes('3p') || needs.includes('dp'));
        
        if (spinPart) {
          // Checkbox ATTIVO: mostra solo azioni con group, 3p, dp
          return hasGroupTags;
        } else {
          // Checkbox DISATTIVO: esclude azioni con group, 3p, dp
          return !hasGroupTags;
        }
      });
    }
    // --- LOGICA COMPATIBILIT√Ä MIGLIORATA ---
    // 1. Estrai azione (con compatibilit√† inversa se luogo √® bloccato)
    let actionCodes = allOptions['azione'] || [];
    actionCodes = filterByLevel(actionCodes, 'azione');
    actionCodes = filterByGroup(actionCodes, 'azione');
    
    // Se il luogo √® bloccato, filtra le azioni per compatibilit√†
    if (locked['luogo']) {
      const lockedLuogo = locked['luogo'];
      actionCodes = actionCodes.filter(actionCode => 
        isActionLocationCompatible(actionCode, lockedLuogo)
      );
      
      // Mostra info sulla compatibilit√† inversa
      const luogoEntry = mapping[lockedLuogo];
      if (luogoEntry && luogoEntry.supports && luogoEntry.supports.length > 0) {
        console.log(`üéØ Compatibilit√† inversa: luogo "${luogoEntry.label}" supporta [${luogoEntry.supports.join(', ')}] - ${actionCodes.length} azioni compatibili`);
      }
    }
    
    let actionChoice = locked['azione'] && actionCodes.includes(locked['azione']) ? locked['azione'] : weightedChoice(actionCodes);
    
    // 2. Estrai luogo compatibile con l'azione
    const luogoCodes = allOptions['luogo'] || [];
    let filteredLuogoCodes = filterByLevel(luogoCodes, 'luogo');
    
    // Funzione per verificare compatibilit√† azione-luogo
    function isActionLocationCompatible(actionCode, locationCode) {
      const actionEntry = mapping[actionCode];
      const locationEntry = mapping[locationCode];
      
      if (!actionEntry || !locationEntry) return true; // Se mancano dati, considera compatibile
      
      const actionNeeds = actionEntry.needs || [];
      const locationSupports = locationEntry.supports || [];
      
      // Se l'azione non ha needs specifici, √® compatibile con qualsiasi luogo
      if (actionNeeds.length === 0) return true;
      
      // Controlla i tag rilevanti per la compatibilit√†
      const relevantTags = ['outdoor', 'public', 'group', '3p', 'dp', 'bondage', 'acqua', 'superficie', 'spazio_minimo', 'sospensione', 'doccia'];
      
      for (const tag of actionNeeds) {
        if (relevantTags.includes(tag)) {
          // Se l'azione richiede un tag, il luogo deve supportarlo
          if (!locationSupports.includes(tag)) {
            return false;
          }
        }
      }
      
      return true;
    }
    
    // Filtra i luoghi in base alla compatibilit√† con l'azione scelta
    let compatibleLuoghi = filteredLuogoCodes.filter(luogoCode => 
      isActionLocationCompatible(actionChoice, luogoCode)
    );
    
    // Mostra info sulla compatibilit√† se applicata
    const actionEntry = mapping[actionChoice];
    if (actionEntry && actionEntry.needs && actionEntry.needs.length > 0) {
      const relevantNeeds = actionEntry.needs.filter(tag => 
        ['outdoor', 'public', 'group', '3p', 'dp', 'bondage', 'acqua', 'superficie', 'spazio_minimo', 'sospensione', 'doccia'].includes(tag)
      );
      if (relevantNeeds.length > 0 && compatibleLuoghi.length < filteredLuogoCodes.length) {
        console.log(`üéØ Compatibilit√† applicata: azione "${actionEntry.label}" richiede [${relevantNeeds.join(', ')}] - ${compatibleLuoghi.length}/${filteredLuogoCodes.length} luoghi compatibili`);
      }
    }
    
    // Se non ci sono luoghi compatibili, usa tutti i luoghi filtrati per livello
    if (compatibleLuoghi.length === 0) {
      compatibleLuoghi = filteredLuogoCodes;
      console.log(`‚ö†Ô∏è Nessun luogo compatibile trovato per l'azione "${actionEntry?.label}", usando tutti i luoghi disponibili`);
    }
    
    let luogoChoice;
    if (locked['luogo'] && filteredLuogoCodes.includes(locked['luogo'])) {
      luogoChoice = locked['luogo'];
      // Se il luogo bloccato non √® compatibile, cerca un compatibile
      if (!isActionLocationCompatible(actionChoice, luogoChoice)) {
        luogoChoice = compatibleLuoghi.length > 0 ? weightedChoice(compatibleLuoghi) : filteredLuogoCodes[0];
      }
    } else {
      luogoChoice = weightedChoice(compatibleLuoghi);
    }
    
    // 3. Estrai le altre categorie normalmente
    let codes = { azione: actionChoice, luogo: luogoChoice };
    Object.keys(allOptions).forEach(cat => {
      if (cat === 'azione' || cat === 'luogo') return;
      const opts = allOptions[cat] || [];
      const filtered = filterByLevel(opts, cat);
      codes[cat] = locked[cat] && filtered.includes(locked[cat]) ? locked[cat] : weightedChoice(filtered);
    });
    // Simula la risposta del backend
    const data = {
      codes,
      readable: codes, // verr√† tradotto da renderCards con mapping
      options: allOptions
    };
    await startSpinningAnimation(data);
    currentCodes = data.codes;
    renderCards(data);
  } catch (error) {
    console.error('Error during spin:', error);
  } finally {
    spinBtn.disabled = false;
    spinBtn.style.opacity = '1';
  }
}

document.getElementById('spinBtn').onclick=spin;
document.getElementById('like').onclick=()=>sendFeedback(true);
document.getElementById('dislike').onclick=()=>sendFeedback(false);
document.getElementById('osareBtn').onclick=()=>sendFeedback('osare');

function saveHistory(codes, like) {
  let history = JSON.parse(localStorage.getItem('slotlove_history') || '[]');
  history.push({ codes, like, ts: Date.now() });
  if (history.length > 20) history = history.slice(-20);
  localStorage.setItem('slotlove_history', JSON.stringify(history));
}

async function sendFeedback(like){
  saveHistory(currentCodes, like);
  
  // Invia anche al backend per Google Sheets
  try {
    // Crea la combinazione completa per il contesto
    let combination = '';
    if (currentCodes) {
      for (const [cat, catCode] of Object.entries(currentCodes)) {
        if (catCode && cat !== 'partecipanti') {
          const label = mapping && mapping[catCode] ? 
            (typeof mapping[catCode] === 'object' ? mapping[catCode].label : mapping[catCode]) : 
            catCode;
          combination += `${cat}: ${label}\n`;
        }
      }
    }
    
    // Invia al backend
    const response = await fetch('/combination-feedback', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        codes: currentCodes,
        like: like,
        combination: combination
      })
    });
    
    if (!response.ok) {
      console.error('Errore nell\'invio feedback combinazione al backend');
    }
  } catch (error) {
    console.error('Errore nell\'invio feedback combinazione:', error);
  }
}

document.getElementById('partChk').onchange = () => {
  if (lastSpinData) renderCards(lastSpinData);
};

// Show empty cards initially
(function(){
  document.getElementById('spinBtn').disabled = true;
  document.getElementById('spinBtn').style.opacity = '0.7';
  loadMapping().then(loadAllOptions);
})();

// Aggiungi il listener per chiudere le explanation box quando si clicca fuori dalla card
document.addEventListener('click', (e) => {
  document.querySelectorAll('.explanation-box').forEach(box => {
    if (!box.parentElement.contains(e.target)) {
      box.style.display = 'none';
      box.parentElement.classList.remove('showing-explanation');
    }
  });
});

// Alla fine del caricamento iniziale, mostra le card vuote con la struttura giusta
window.addEventListener('DOMContentLoaded', () => {
  expertMode = false;
  loadMapping().then(loadAllOptions).then(() => {
    renderEmptyCards();
  });
});

// Funzioni overlay zoom - VERSIONE CORRETTA
function openZoomedCard(card) {
  console.log('Opening zoomed card'); // Debug
  
  // Crea overlay
  let overlay = document.createElement('div');
  overlay.className = 'overlay-card-zoom';
  overlay.onclick = function(e) {
    if (e.target === overlay) {
      closeZoomedCard();
    }
  };
  document.body.appendChild(overlay);
  
  // Estrai solo il testo dei consigli dalla card
  const cardBack = card.querySelector('.card-back');
  let tipsText = 'Nessun consiglio disponibile.';
  
  if (cardBack) {
    // Trova il div che contiene il testo dei consigli (il secondo div)
    const tipsDiv = cardBack.querySelector('div:last-child');
    if (tipsDiv) {
      tipsText = tipsDiv.textContent || tipsDiv.innerText || 'Nessun consiglio disponibile.';
    }
  }
  
  // Crea un contenitore per i consigli in grande
  let tipsContainer = document.createElement('div');
  tipsContainer.className = 'zoomed-tips-container';
  tipsContainer.style.cssText = `
    position: fixed;
    z-index: 1010;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    background: rgba(40,30,60,0.97);
    color: #fff;
    padding: 2rem;
    border-radius: 18px;
    box-shadow: 0 16px 64px 0 rgba(40,30,60,0.32), 0 2px 8px rgba(127,92,255,0.18);
    max-width: 90vw;
    max-height: 90vh;
    overflow-y: auto;
    word-wrap: break-word;
    overflow-wrap: break-word;
    font-size: 1.2rem;
    line-height: 1.6;
    text-align: left;
    transition: transform 0.28s cubic-bezier(.4,1.4,.6,1);
  `;
  
  // Aggiungi il contenuto dei consigli
  tipsContainer.innerHTML = `
    <div style="font-size:1.4em;font-weight:600;margin-bottom:1em;text-align:center;">Consigli</div>
    <div style="white-space:pre-line;">${tipsText}</div>
  `;
  
  overlay.appendChild(tipsContainer);
  document.body.classList.add('no-scroll');
}

function closeZoomedCard() {
  console.log('Closing zoomed card'); // Debug
  let overlay = document.querySelector('.overlay-card-zoom');
  if (!overlay) return;
  
  overlay.remove();
  document.body.classList.remove('no-scroll');
}
</script>
</body>
</html> 